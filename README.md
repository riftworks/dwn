# Decentralized Web Nodes (DWN)

**Web5 systems are based on two major things: DIDs and DWNs.** Each user having
a DID automatically gets a DWN tied to it. This repository aims at creating a
DWN for the CommonRift Web5 System (referred to as `system` and called Rift).

> [!WARNING]
> As mentioned in the org's README, TBD's Web5 guidelines are not followed due
> to concerns about viability. Our Web5 system goes far beyond what they
> intend to create.

## What is this DWN?

This DWN app consists of a server that will listen for data input, store data
locally, and react to system events. It is important to see a DWN as the 
ledger of a user. It can be hosted locally and made available publicly, hosting
can be delegated to someone else, or a commercial entity. In this last case, we
may need to make this DWN app handle multiple identities and other storage
providers in a special mode.

## How it works?

The DWN app can run as long as it wants (forever is better), and holds a crypto 
strong identity. It remains unclaimed as long as a user does not target it to
be it's DWN and DID holder. The user gets the identity generated by this DWN.

The DWN is the bodyguard of the user's data, it buffers every data generated by
the user and handle requests from other DWNs to retrieve them.

> [!NOTE]
> For example, the user's health app is storing data on Web5, the user could
> have granted the DWN buffering access to this health data (meaning a copy is
> on the DWN for some time). It could have also granted the DWN with an
> authorization to automatically give/sell this data to specific DIDs.
>
> In this case, the DWN receive a request from another DWN (let's say a lab)
> that wants to retrieve heart rate data. If the user is disconnected, and the
> DWN is granted sharing autonomy for this dataset, the data is automatically
> shared.
>
> In the case the user is connected, it receives a request to grant access or
> not to this service.

## Networking

> [!IMPORTANT]
> It is highly recommended to have an understanding of the DID protocol before
> continuing: [Decentralized IDentifiers Protocol's README](https://github.com/riftworks/proto-did/blob/main/README.md)

Under the system, two distinct spaces must be distinguished:
- The `did://` space, for DWNs with zk cryptographic verifications, ARs, ...
- The `http://` space, for links between DWNs and devices

### DWN with multiple identities with the `did://` protocol

This protocol allows a DWN to hold multiple DID identities with cryptographic
verifications since this protocol targets a specific DID.

In this case, data for each DID is isolated and has a specific configuration
loaded by the DWN on-demand.

## Storing data

Data is stored in multiple kinds of mediums. Most data is stored by default on
device unless the user grants the DWN buffering access to this data (which can
be revoked at anytime).

The DWN can be configured to store data locally (if it has enough room) or on
external mediums through DB and file storage. The DWN and devices will support
by defaul document databases (JSON trees) and file storage.

Apps the user gave consent to will be able to modify certain data in the set
they generated.

> For example:
> - A social network app uses this network to tie profiles to identities.
> - The user connects to this app, and the DWN's app notifies the user's DWN of
>   all the storage rules of the app, the user's DWN creates a namespace for
>   the app and whitelists the app's DWN to read and apply the storage rules
>   on this namespace.
> - Every data generated is therefore stored on the user's identity.
> - Someone likes a post of the user.
> - The app's DWN notifies the user's DWN of a change.
> - The DWN stores this change.

Here is what a DWN internal storage representation would be:

```
DWN
├── [storage mode]
│   └── [namespace]
│       └── [database name]
├── Permissions
│   └── @twouiteur
│       ├── OWN: kv.@twouiteur, raw.@twouiteur
│       └── READ: raw.@gallery_app.pictures
├── KV Storage
│   └── @twouiteur
│       ├── posts_metadata
│       └── users
└── Raw Storage
    ├── @twouiteur
    │   └── posts
    └── @gallery_app
        ├── pictures
        └── videos
```

### Temperature storage

Tthis section addresses a concrete limitation: While storage capacity is finite,
content generation is effectively limitless.

Therefore, we need a way of handling storage by temperature:
- **Hot tier**: Small files (> 100Mb) and data accessed often are stored on
    the user's DWN for fast access.
- **Warm tier**: Data and files are offloaded from the DWN to a federated DWN
    storage network. DWNs offers storage for any capacity at a specific price
    and based on regions, all rated based on availability and consistency. The
    data is stored cryptographically by the user's DWN. **This tier is managed
    by the did:// protocol.**
- **Cold tier**: Data is offloaded to the IPFS and hashes to those data is kept
    by the user's DWN. It allows for smaller storage costs, storing extra-large
    files, and offloading the DWN network with unecessary content.

> [!IMPORTANT]
> Both warm and cold tier storage have a cost. And finding a great balance to
> make payments from currencies to those services as seamless as possible is
> hard.
>
> As of now, each DWN will create a wallet on the Bitcoin Lightning Network for
> its user. This wallet is entirely managed the the DWN. The user will have to
> submit payment information if they want to use all storage tiers.
>
> The DWN will automatically top-up (up to a monthly limit) the BLN if the
> balance is too low for the expected storage cost.

Data cost and credit will be vulgarised as much as possible for the end-user to
make it easy to understand (with available advanced stats of what is happening)

It is also important to understand that user-generated data on dApps, with 
frequent access will lead the dApp to pay a fee to the user (using the BLN)
network for storage.

> Imagine a Twitter-like social network on this network, every data generated
> by the user (posts, comments) are saved on the user's DWN since they own
> those data. If the service frequently get access to this data, it will have
> to pay a storage fee to the user to cover the user's fees for storing those
> data for the app.

Therefore, the DWN will do active monitoring of assets stored on warm and cold
tier to spend the smallest amount of money possible on storage and ensure
maximum availability of data.

*However, such a system would allow in the future to implement other services
based on this payment method. And BLN may be ditched out for a Web5 native
payment method later.*

## Built-in privacy

As defined in my thesis (Ensure individual's ownership over generated data),
we could use T-Levels anonymity to share data to brokers with a specific number
of identities.

Moreover, depending on the level of anonymity, we could spoof DIDs to DWNs to
ensure no data is linked to a specific DID.

## Built-in security

### Keys

Every assymetrical keys generated will have to be issued by the NIST-approved
Falcon cryptographic system.

### Anti-spoofing verifications

Verifying a DWN holds the correct identity is the painpoint of naive systems.
Doing a simple challenge by verifying the DWN holds the correct key-pair is not
enough as it does not prove it is meant to hold a given DID. Therefore, any DWN 
is able to pretend it is honest by simply generating an appropriate key-pair.

To prevent spoofing, DWNs will be using ZK-proofs of knowledge and every key
and the DID are generated by the DWN from a master key. Using a master key
allows for every DWN to prove a DWN is holding the correct DID without exposing 
any sensitive data.

It is done by challenging a DWN to prove it can derive the correct key for a
specific epoch. The DWN will have to give this key and a proof of knowledge of
the master key. DWNs will then be able, using Schnorr-like proofs, to determine
if the derived key has the same master key as the DID. The verification flow is
the following:

- Challenger: "Prove you can derive the signing key for epoch N"  
- DWN: Provides derived key + Schnorr-like proof of master key knowledge
- Challenger: Verifies proof confirms same master key generated both DID and
    derived key

In résumé:
- **Master Key Architecture**: each DWN generates a master key that never leaves
    the node
- **Deterministic Derivation**: both the DID and all operational keys derive
    from this master key
- **ZK Proof of Knowledge**: the DWN proves knowledge of the master key without
    revealing it
- **Epoch-Based Verification**: verifiers can request proof of key derivation
    for any epoch

### Keys rotation

Keys are rotated every 24 hours to ensure more security against attacks and
spoofing. Rotating keys require the DWN and devices to communicate challenges
using ones that will be replaced, ensuring no spoofer can get approved by
taking advantage of a key rotation.

### Passkeys

Since Web5 is the future, we should not hesitate in using new techs. Therefore,
passkeys are used on-device as a way for the DWN to verify the identity of the
devices connected to it. It allows for full control of the decentralized 
identity and for portability.

> [!INFO]
> Passkeys allows for a device to generate with a service assymetrical keys.
> The service keeps the public key and the device the private key. The key is
> protected by secure hardware (TPM, ...) allowing for trusted biometric
> connection, therefore real identity verification.

### Delays

Every new device being paired with a DWN will have to undergo a 24 hours
timeout before retrieving data from the DWN, creating security rules, etc.

## Sharing DID identity across user's devices

Allowing multiple devices to share the same identity works the same as sharing
any kind of data to a DWN. The identity is a shareable data but it requires
authorization with the user connected, no delegated authorizations.

What happens is that the DWN will generate a new key-pair with a new device.

### Recover access to a DWN if all associated devices are lost

The user is never aware of its master key. Therefore, when the user connects
for the first time to its DWN, the DWN will generate a 4kb symmetric key
(Quantum-proof: Introduction to post-quantum cryptography, Daniel J. Bernstein)
and give the user with the DID encrypted with this key. If the user submits by
any means (without a linked device) the encrypted DID, the DWN will link this
device and remove access from every other device.

## The Local App Model

One of the major issues of implementing such a system is the current app model.
Under this model, the network could quickly see emerge superclusters that 
consists of services often accessed by DWNs. Those centralized apps causes
issues regarding network speed and integrity since they cannot access data 
directly from DWNs (as described in the DID protocol), they serve as a relay
for users to interact with app with, will undergo a massive traffic that will
cost a lot.

To overcome those issues, we must think of a new app model. This model is
local-first. Instead of having a centralized service, each DWN that need to
access a specific app will download a copy of it locally as a microservice. 
This copy will be targetable through the DID protocol, allowing for DWNs to 
communicate directly with each other. It does not prevent the app from using
other services, such as AWS to target a service that will make suggestions
based on content.

Each app will have full uncrypted access to the data it generates.

> [!NOTE]
> Such a system will greatly reduce the operational complexity of the whole
> network, especially regarding bandwidth and storage operations.
>
> It also brings unconsiderable benefits for offline-first use cases.

The app manifest (`manifest.json`) is the core component of every app under
this system, it gives entrypoints of the app, paths, names, ... to use. 

Here is an example of a manifest for a social network app:

```json
{
    "name": "twouiteur",
    "version": "2.1.1",
    "source": "did://twouiteur@app/",
    "services": [
        {
            "route": "/profile/:id",
            "handler": "src/routes/get_profile.go"
        },
        {
            "route": "/post/:id",
            "handler": "src/routes/get_post.rs"
        }
    ],
    "storage": [
        {
            "mode": "kv",
            "database_name": "posts_metadata"
        },
        {
            "mode": "kv",
            "database_name": "users"
        },
        {
            "mode": "raw",
            "database_name": "posts"
        },
        {
            "mode": "raw",
            "database_name": "pictures",
            "owned_by": "@gallery_app",
            "permission": "read"
        }
    ]
}
```

Each route will be made public under a namespace, as it may have been guessed
the namespace is `@[app_name]` for both storage and routing.

### Runtimes

Three runtimes are supported out-of-the-box for DWNs. `JavaScript/TypeScript`
for convenience, `Rust` and `Go` for performance and really-low cold start
impact.

Runtimes are automatically determined based on file extensions and the DWN
automatically build routes on installing to improve efficiency. 

# How to use

- `--multi-identities=N` will enable the DWN to manage at most `N` identities.
- `--storage-provider` will enable the DWN to be a storage provider for others.
- `--full-ar-record` will make the local AR size infinite (intended for fat
    nodes)
- `--config=<path>` will load the configuration at the given path.

## `config.toml`

The configuration file stores customisable information about the current node,
such as storage provider configuration.

```toml
[storage.provider]
storage_type = main | replicated
allocated_size = 10Go
directory = /mnt/dwn/storage
bln_address = 0x0000

[storage.buffering]
max_buffering_size = 20Go
directory = /mnt/dwn/buffering

[ar]
max_size = 100Mo        # Optional if `unlimited_ar_size` is set
unlimited_dht_size = false

[identities]
enable_multi_identities = true
max_identities = 6
```

## Roadmap

- [ ] DID setup and enforcing
    - [ ] DID generation
    - [ ] Keys exchange between devices
- [ ] Access control rules
- [ ] Data buffering
- [ ] DWN and devices data sharing
    - [ ] Data exchange
    - [ ] Finding DWNs by DIDs
    - [ ] Authentication data exchange

